{"ast":null,"code":"import { normalizeValues } from './utils';\nvar thicknessPad = {\n  xlarge: 'large',\n  large: 'medium',\n  medium: 'small',\n  small: 'xsmall',\n  xsmall: 'xxsmall'\n};\nexport var round = function round(value, decimals) {\n  return Number(Math.round(value + \"e\" + decimals) + \"e-\" + decimals);\n};\n\nvar alignMax = function alignMax(value, interval) {\n  if (value > 0) return value - value % interval + interval;\n  if (value < 0) return value + value % interval;\n  return value;\n};\n\nvar alignMin = function alignMin(value, interval) {\n  if (value > 0) return value - value % interval;\n  if (value < 0) return value - value % interval - interval;\n  return value;\n};\n\nexport var calcBounds = function calcBounds(values, options) {\n  if (options === void 0) {\n    options = {};\n  } // coarseness influences the rounding of the bounds, the smaller the\n  // number, the more the bounds will be rounded. e.g. 111 -> 110 -> 100\n  // Normalize to an array. Backwards compatible has no coarseness for x-axis\n\n\n  var coarseness = Array.isArray(options.coarseness) && options.coarseness || options.coarseness && [undefined, options.coarseness] || [undefined, 5]; // the number of steps is one less than the number of labels\n\n  var steps = options.steps || [1, 1];\n  var calcValues = normalizeValues(values || []); // min and max values\n\n  var minX;\n  var maxX;\n  var minY;\n  var maxY;\n\n  if (calcValues.length) {\n    // Calculate the max and min values.\n    calcValues.filter(function (value) {\n      return value !== undefined;\n    }).forEach(function (value) {\n      var x = value.value[0];\n\n      if (x !== undefined) {\n        minX = minX === undefined ? x : Math.min(minX, x);\n        maxX = maxX === undefined ? x : Math.max(maxX, x);\n      }\n\n      var y = value.value[1];\n\n      if (y !== undefined) {\n        minY = minY === undefined ? y : Math.min(minY, y);\n        maxY = maxY === undefined ? y : Math.max(maxY, y);\n      } // handle ranges of values\n\n\n      var y2 = value.value[2];\n\n      if (y2 !== undefined) {\n        minY = Math.min(minY, y2);\n        maxY = Math.max(maxY, y2);\n      }\n    }); // when max === min, offset them so we can show something\n\n    if (maxX === minX) {\n      if (maxX > 0) minX = maxX - 1;else maxX = minX + 1;\n    }\n\n    if (maxY === minY) {\n      if (maxY > 0) minY = maxY - 1;else maxY = minY + 1;\n    } // Calculate some reasonable bounds based on the max and min values.\n    // This is so values like 87342.12 don't end up being displayed as the\n    // graph axis labels.\n\n\n    var cX = coarseness[0],\n        cY = coarseness[1];\n\n    if (cX) {\n      var deltaX = maxX - minX;\n      var intervalX = Number.parseFloat((deltaX / cX).toPrecision(1));\n      minX = alignMin(minX, intervalX);\n      maxX = alignMax(maxX, intervalX);\n    }\n\n    if (cY) {\n      var deltaY = maxY - minY;\n      var intervalY = Number.parseFloat((deltaY / cY).toPrecision(1));\n      minY = alignMin(minY, intervalY);\n      maxY = alignMax(maxY, intervalY);\n    }\n\n    if (minY < 0 && maxY > 0 && Math.abs(minY) !== Math.abs(maxY)) {\n      // Adjust min and max when crossing 0 to ensure 0 will be shown on\n      // the Y axis based on the number of steps.\n      // const ratio = Math.abs(max) / Math.abs(min);\n      var stepInterval = (maxY - minY) / steps[1];\n      var minSteps = minY / stepInterval;\n      var maxSteps = maxY / stepInterval;\n\n      if (Math.abs(minSteps) < Math.abs(maxSteps)) {\n        stepInterval = maxY / Math.floor(maxSteps);\n        maxY = stepInterval * Math.floor(maxSteps);\n        minY = stepInterval * Math.floor(minSteps);\n      } else {\n        stepInterval = Math.abs(minY / Math.ceil(minSteps));\n        minY = stepInterval * Math.ceil(minSteps);\n        maxY = stepInterval * Math.ceil(maxSteps);\n      }\n    }\n  }\n\n  var bounds;\n  if (calcValues.length) bounds = [[minX, maxX], [minY, maxY]];else bounds = [[], []];\n  return bounds;\n};\nexport var calcs = function calcs(values, options) {\n  if (values === void 0) {\n    values = [];\n  }\n\n  if (options === void 0) {\n    options = {};\n  } // the number of steps is one less than the number of labels\n\n\n  var steps = options.steps || [1, 1];\n  var bounds = options.bounds || calcBounds(values, options);\n  if (options.min !== undefined) bounds[1][0] = options.min;\n  if (options.max !== undefined) bounds[1][1] = options.max;\n  var dimensions = [round(bounds[0][1] - bounds[0][0], 2), round(bounds[1][1] - bounds[1][0], 2)]; // Calculate x and y axis values across the specfied number of steps.\n\n  var yAxis = [];\n  var y = bounds[1][1]; // To deal with javascript math limitations, round the step with 4 decimal\n  // places and then push the values with 2 decimal places\n\n  var yStepInterval = round(dimensions[1] / steps[1], 4);\n\n  while (round(y, 2) >= bounds[1][0]) {\n    yAxis.push(round(y, 2));\n    y -= yStepInterval;\n  }\n\n  var xAxis = [];\n  var x = bounds[0][0];\n  var xStepInterval = round(dimensions[0] / steps[0], 4);\n\n  while (round(x, 2) <= bounds[0][1]) {\n    xAxis.push(round(x, 2));\n    x += xStepInterval;\n  }\n\n  var _options = options,\n      thickness = _options.thickness;\n\n  if (!thickness) {\n    // Set bar thickness based on number of values being rendered.\n    // Someday, it would be better to include the actual rendered size.\n    // These values were emirically determined, trying to balance visibility\n    // and overlap across resolutions.\n    if (values.length < 5) {\n      thickness = 'xlarge';\n    } else if (values.length < 11) {\n      thickness = 'large';\n    } else if (values.length < 21) {\n      thickness = 'medium';\n    } else if (values.length < 61) {\n      thickness = 'small';\n    } else if (values.length < 121) {\n      thickness = 'xsmall';\n    } else {\n      thickness = 'hair';\n    }\n  }\n\n  var pad = thicknessPad[thickness];\n  return {\n    axis: [xAxis, yAxis],\n    bounds: bounds,\n    dimensions: dimensions,\n    pad: pad,\n    thickness: thickness\n  };\n};","map":{"version":3,"sources":["/Users/jeffreynaef/go/src/github.com/n3wscott/sockeye/frontend/node_modules/grommet/es6/components/Chart/calcs.js"],"names":["normalizeValues","thicknessPad","xlarge","large","medium","small","xsmall","round","value","decimals","Number","Math","alignMax","interval","alignMin","calcBounds","values","options","coarseness","Array","isArray","undefined","steps","calcValues","minX","maxX","minY","maxY","length","filter","forEach","x","min","max","y","y2","cX","cY","deltaX","intervalX","parseFloat","toPrecision","deltaY","intervalY","abs","stepInterval","minSteps","maxSteps","floor","ceil","bounds","calcs","dimensions","yAxis","yStepInterval","push","xAxis","xStepInterval","_options","thickness","pad","axis"],"mappings":"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","sourcesContent":["import { normalizeValues } from './utils';\nvar thicknessPad = {\n  xlarge: 'large',\n  large: 'medium',\n  medium: 'small',\n  small: 'xsmall',\n  xsmall: 'xxsmall'\n};\nexport var round = function round(value, decimals) {\n  return Number(Math.round(value + \"e\" + decimals) + \"e-\" + decimals);\n};\n\nvar alignMax = function alignMax(value, interval) {\n  if (value > 0) return value - value % interval + interval;\n  if (value < 0) return value + value % interval;\n  return value;\n};\n\nvar alignMin = function alignMin(value, interval) {\n  if (value > 0) return value - value % interval;\n  if (value < 0) return value - value % interval - interval;\n  return value;\n};\n\nexport var calcBounds = function calcBounds(values, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  // coarseness influences the rounding of the bounds, the smaller the\n  // number, the more the bounds will be rounded. e.g. 111 -> 110 -> 100\n  // Normalize to an array. Backwards compatible has no coarseness for x-axis\n  var coarseness = Array.isArray(options.coarseness) && options.coarseness || options.coarseness && [undefined, options.coarseness] || [undefined, 5]; // the number of steps is one less than the number of labels\n\n  var steps = options.steps || [1, 1];\n  var calcValues = normalizeValues(values || []); // min and max values\n\n  var minX;\n  var maxX;\n  var minY;\n  var maxY;\n\n  if (calcValues.length) {\n    // Calculate the max and min values.\n    calcValues.filter(function (value) {\n      return value !== undefined;\n    }).forEach(function (value) {\n      var x = value.value[0];\n\n      if (x !== undefined) {\n        minX = minX === undefined ? x : Math.min(minX, x);\n        maxX = maxX === undefined ? x : Math.max(maxX, x);\n      }\n\n      var y = value.value[1];\n\n      if (y !== undefined) {\n        minY = minY === undefined ? y : Math.min(minY, y);\n        maxY = maxY === undefined ? y : Math.max(maxY, y);\n      } // handle ranges of values\n\n\n      var y2 = value.value[2];\n\n      if (y2 !== undefined) {\n        minY = Math.min(minY, y2);\n        maxY = Math.max(maxY, y2);\n      }\n    }); // when max === min, offset them so we can show something\n\n    if (maxX === minX) {\n      if (maxX > 0) minX = maxX - 1;else maxX = minX + 1;\n    }\n\n    if (maxY === minY) {\n      if (maxY > 0) minY = maxY - 1;else maxY = minY + 1;\n    } // Calculate some reasonable bounds based on the max and min values.\n    // This is so values like 87342.12 don't end up being displayed as the\n    // graph axis labels.\n\n\n    var cX = coarseness[0],\n        cY = coarseness[1];\n\n    if (cX) {\n      var deltaX = maxX - minX;\n      var intervalX = Number.parseFloat((deltaX / cX).toPrecision(1));\n      minX = alignMin(minX, intervalX);\n      maxX = alignMax(maxX, intervalX);\n    }\n\n    if (cY) {\n      var deltaY = maxY - minY;\n      var intervalY = Number.parseFloat((deltaY / cY).toPrecision(1));\n      minY = alignMin(minY, intervalY);\n      maxY = alignMax(maxY, intervalY);\n    }\n\n    if (minY < 0 && maxY > 0 && Math.abs(minY) !== Math.abs(maxY)) {\n      // Adjust min and max when crossing 0 to ensure 0 will be shown on\n      // the Y axis based on the number of steps.\n      // const ratio = Math.abs(max) / Math.abs(min);\n      var stepInterval = (maxY - minY) / steps[1];\n      var minSteps = minY / stepInterval;\n      var maxSteps = maxY / stepInterval;\n\n      if (Math.abs(minSteps) < Math.abs(maxSteps)) {\n        stepInterval = maxY / Math.floor(maxSteps);\n        maxY = stepInterval * Math.floor(maxSteps);\n        minY = stepInterval * Math.floor(minSteps);\n      } else {\n        stepInterval = Math.abs(minY / Math.ceil(minSteps));\n        minY = stepInterval * Math.ceil(minSteps);\n        maxY = stepInterval * Math.ceil(maxSteps);\n      }\n    }\n  }\n\n  var bounds;\n  if (calcValues.length) bounds = [[minX, maxX], [minY, maxY]];else bounds = [[], []];\n  return bounds;\n};\nexport var calcs = function calcs(values, options) {\n  if (values === void 0) {\n    values = [];\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  // the number of steps is one less than the number of labels\n  var steps = options.steps || [1, 1];\n  var bounds = options.bounds || calcBounds(values, options);\n  if (options.min !== undefined) bounds[1][0] = options.min;\n  if (options.max !== undefined) bounds[1][1] = options.max;\n  var dimensions = [round(bounds[0][1] - bounds[0][0], 2), round(bounds[1][1] - bounds[1][0], 2)]; // Calculate x and y axis values across the specfied number of steps.\n\n  var yAxis = [];\n  var y = bounds[1][1]; // To deal with javascript math limitations, round the step with 4 decimal\n  // places and then push the values with 2 decimal places\n\n  var yStepInterval = round(dimensions[1] / steps[1], 4);\n\n  while (round(y, 2) >= bounds[1][0]) {\n    yAxis.push(round(y, 2));\n    y -= yStepInterval;\n  }\n\n  var xAxis = [];\n  var x = bounds[0][0];\n  var xStepInterval = round(dimensions[0] / steps[0], 4);\n\n  while (round(x, 2) <= bounds[0][1]) {\n    xAxis.push(round(x, 2));\n    x += xStepInterval;\n  }\n\n  var _options = options,\n      thickness = _options.thickness;\n\n  if (!thickness) {\n    // Set bar thickness based on number of values being rendered.\n    // Someday, it would be better to include the actual rendered size.\n    // These values were emirically determined, trying to balance visibility\n    // and overlap across resolutions.\n    if (values.length < 5) {\n      thickness = 'xlarge';\n    } else if (values.length < 11) {\n      thickness = 'large';\n    } else if (values.length < 21) {\n      thickness = 'medium';\n    } else if (values.length < 61) {\n      thickness = 'small';\n    } else if (values.length < 121) {\n      thickness = 'xsmall';\n    } else {\n      thickness = 'hair';\n    }\n  }\n\n  var pad = thicknessPad[thickness];\n  return {\n    axis: [xAxis, yAxis],\n    bounds: bounds,\n    dimensions: dimensions,\n    pad: pad,\n    thickness: thickness\n  };\n};"]},"metadata":{},"sourceType":"module"}